/*
   Ported by ACP Aviation from quadrotor project 
   ### References
   1. A Simple Learning Strategy for High-Speed Quadrocopter Multi-Flips
      - Sergei Lupashin, Angela Sch¨ollig, Michael Sherback, Raffaello D’Andrea
   2. Adaptive Open-Loop Aerobatic Maneuvers for Quadrocopters
      - Sergei Lupashin, Rafaello D’Andrea
   3. Adaptive fast open-loop maneuvers for quadrocopters
      - Sergei Lupashin, Rafaello D’Andrea
*/
#include "definitions.h"
#include <stdint.h>
#include "quadrotor.h"
#include "Struts.h"
#include "gc_events.h"

/*------------------------------------------------------------------------------
 *                          Function Prototypes.
 *----------------------------------------------------------------------------*/
thrust_obj_t ENG_motor_thrust(const Vectr moments, float32_t coll_thrust);
mat33 ENG_angular_rotation_matrix(const Vectr euler_angles);
mat33 ENG_rotation_matrix(const Vectr euler_angles);
mat33 mat33_make_inertia_matrix( const Vectr inertia );
Vectr dot_mat33_vectr( const mat33 matr, const Vectr vec );
dVectr dot_Matrix3f64_vectr( const Matrix3f64_t matr, const dVectr vec );
Vectr ENG_moments( const Vectr desired_acc, const Vectr angular_vel);
Vectr ENG_dt_eulerangles_to_angular_velocity(const Vectr dtEuler, const Vectr euler_angles);
Vectr ENG_angular_velocity_to_dt_eulerangles(const Vectr omega, const Vectr euler_angles);
float32_t sumThrust( const thrust_obj_t thrusts );
Vectr ENG_acceleration(thrust_obj_t thrusts, const Vectr euler_angles);
#if (ENG_noOfMtr == 4)
Vectr ENG_angular_acceleration(const Vectr omega, const thrust_obj_t thr);
void ENG_integrator(integrator_obj_t *out, const Vectr euler, const Vectr omega, const float32_t coll_thrust, const Vectr desired_angular_acc);
#endif
/* Compute the individual motor thrusts

    Parameters
    ----------
    The moments along each of the axis [Mp, Mq, Mr]
    coll_thrust : float
        The collective thrust generated by all motors
    Returns
    -------
        The thrust generated by each motor [T1, T2, T3, T4]
*/			
thrust_obj_t ENG_motor_thrust(const Vectr moments, float32_t coll_thrust)
{	
    thrust_obj_t th;
    int8_t cnt;
    float32_t temp1add = coll_thrust + moments.x / ENG_thrustToDrag;
    float32_t temp1sub = coll_thrust - moments.x / ENG_thrustToDrag;
    float32_t temp2p = 2.0f * moments.y / ENG_length;
    float32_t temp2q = 2.0f * moments.z / ENG_length;

    for (cnt=0;cnt<ENG_noOfMtr;cnt++)
    {
      if (cnt%2==0)		
        th.thrust[cnt] = (temp1add - temp2q) / 4.0f;
      else
        th.thrust[cnt+1] = (temp1sub + temp2p) / 4.0f;
    }
    return th;		
}
/* 
    Rotation matix to assist conversion between angular velocity
    and derivative of Euler angles
    Use inverse of the matrix to convert from angular velocity to euler rates
*/
mat33 ENG_angular_rotation_matrix(const Vectr euler_angles)
{
    float32_t phi = euler_angles.x;
    float32_t theta = euler_angles.y;
    float32_t psi = euler_angles.z;
    mat33 m;
		
    m.m[0u][0u] = 1.0f;
    m.m[0u][1u] = 0.0f;
    m.m[0u][2u] = sin(theta);
    m.m[1u][0u] = 0.0f;
    m.m[1u][1u] = cos(phi);
    m.m[1u][2u] = cos(theta) * sin(phi);
    m.m[2u][0u] = 0.0f;
    m.m[2u][1u] = sin(phi);
    m.m[2u][2u] = cos(theta) * cos(phi);
    return m;
}

mat33 ENG_rotation_matrix(const Vectr euler_angles)
{
   float32_t phi = euler_angles.x;
   float32_t theta = euler_angles.y;
   float32_t psi = euler_angles.z;
   mat33 m;

   float32_t cphi = cos(phi);
   float32_t sphi = sin(phi);
   float32_t cthe = cos(theta);
   float32_t sthe = sin(theta);
   float32_t cpsi = cos(psi);
   float32_t spsi = sin(psi);

   m.m[0u][0u] = cthe * cpsi;
   m.m[0u][1u] = sphi * sthe * cpsi - cphi * spsi;
   m.m[0u][2u] = cphi * sthe * cpsi + sphi * spsi;
   m.m[1u][0u] = cthe * spsi;
   m.m[1u][1u] = sphi * sthe * spsi + cphi * cpsi;
   m.m[1u][2u] = cphi * sthe * spsi - sphi * cpsi;
   m.m[2u][0u] = -sthe;
   m.m[2u][1u] = cthe * sphi;
   m.m[2u][2u] = cthe * cphi;
   return m;
}

mat33 mat33_make_inertia_matrix( const Vectr inertia )
{
    mat33 m;
    memset((void*)&m,0,sizeof(m));
    m.m[0u][0u] = inertia.x;
    m.m[1u][1u] = inertia.y;
    m.m[2u][2u] = inertia.z;
    return m;	
}

Vectr dot_mat33_vectr( const mat33 matr, const Vectr vec )
{
    Vectr v;
    v.x = (matr.m[0u][0u] * vec.x) + (matr.m[0u][1u] * vec.x) + (matr.m[0u][2u] * vec.x);
    v.y = (matr.m[1u][0u] * vec.y) + (matr.m[1u][1u] * vec.y) + (matr.m[1u][2u] * vec.y);
    v.z = (matr.m[2u][0u] * vec.z) + (matr.m[2u][1u] * vec.z) + (matr.m[2u][2u] * vec.z);
    return v;	
}

dVectr dot_Matrix3f64_vectr( const Matrix3f64_t matr, const dVectr vec )
{
    Vectr v;
    v.x = (matr.a.x * vec.x) + (matr.a.y * vec.x) + (matr.a.z * vec.x);
    v.y = (matr.b.x * vec.y) + (matr.b.y * vec.y) + (matr.b.z * vec.y);
    v.z = (matr.c.x * vec.z) + (matr.c.y * vec.z) + (matr.c.z * vec.z);	
    return v;
}

/*Compute the moments

        Parameters
        ----------
        desired_acc : numpy.array
            The desired angular acceleration that the system should achieve. This
            should be of form [dp/dt, dq/dt, dr/dt]
        angular_vel : numpy.array
            The current angular velocity of the system. This
            should be of form [p, q, r]

        Returns
        -------
        numpy.array
            The desired moments of the system
*/
Vectr ENG_moments(const Vectr desired_acc, const Vectr angular_vel)
{
    /* Vectr inertia_vec = ENG_interia; */
    Vectr inertia_vec;  
    mat33 inertia_matrix,inv_inertia_matrix;
    Vectr part1,part2;

    inertia_vec = mkvec(ENG_intetia_X, ENG_intetia_Y, ENG_intetia_Z);		
    inertia_matrix = mat33_make_inertia_matrix( inertia_vec );
    matrix33_inverse(&inv_inertia_matrix, inertia_matrix);
    part1 = dot_mat33_vectr(inv_inertia_matrix, angular_vel);
    part2 = dot_mat33_vectr(inertia_matrix, angular_vel);
    return (dot_mat33_vectr(inertia_matrix, vadd(desired_acc, vcross(part1, part2))));
}
/*
        """Convert the Euler angle derivatives to angular velocity
        dtEuler = np.array([dphi/dt, dtheta/dt, dpsi/dt])
        """
*/
Vectr ENG_dt_eulerangles_to_angular_velocity(const Vectr dtEuler, const Vectr euler_angles)
{
    return (dot_mat33_vectr(ENG_angular_rotation_matrix(euler_angles), dtEuler));
}
/*
        """Compute Euler angles from angular velocity
        omega = angular velocity :- np.array([p, q, r])
        """
*/
Vectr ENG_angular_velocity_to_dt_eulerangles(const Vectr omega, const Vectr euler_angles)
{
    mat33 rotation_matrix;
    matrix33_inverse(&rotation_matrix, ENG_angular_rotation_matrix(euler_angles));
    return (dot_mat33_vectr(rotation_matrix, omega));
}
float32_t sumThrust( const thrust_obj_t thrusts )
{
    int8_t cnt;
    float32_t sumVal=0.0f;
	
    for (cnt=0;cnt<ENG_noOfMtr;cnt++)
    {	
        sumVal = sumVal + thrusts.thrust[cnt];
    }
    return sumVal;
}
/*
        """Compute the acceleration in inertial reference frame
        thrust = np.array([Motor1, .... Motor4])
        """
*/
Vectr ENG_acceleration(thrust_obj_t thrusts, const Vectr euler_angles)
{
    float32_t force_z_body = sumThrust(thrusts) / ENG_Mass; 
    /* Vectr rotation_matrix = ENG_rotation_matrix(euler_angles); 
    Vectr force_body = mkvec(0.0f, 0.0f, (sumThrust(thrusts) / ENG_Mass)); */
    return (vsub( dot_mat33_vectr( ENG_rotation_matrix(euler_angles), mkvec(0.0f, 0.0f, (sumThrust(thrusts) / ENG_Mass)) ) , mkvec(0.0f, 0.0f, GRAV_CONST) ));
}

/*
        """Compute the angular acceleration in body frame
        omega = angular velocity :- np.array([p, q, r])
        """
*/
#if (ENG_noOfMtr == 4)
Vectr ENG_angular_acceleration(const Vectr omega, const thrust_obj_t thr)
{
    Vectr thrust_matrix; 
    Vectr inertia; 
    mat33 inertia_matrix; 
    mat33 inverse_inertia;

    inertia_matrix = mat33_make_inertia_matrix( inertia );
    thrust_matrix = mkvec((ENG_length * (thr.thrust[1u] - thr.thrust[3u])), (ENG_length * (thr.thrust[2u] - thr.thrust[0u])), (ENG_thrustToDrag * (thr.thrust[0u] - thr.thrust[1u] + thr.thrust[2u] - thr.thrust[3u])));	
    inertia = mkvec(ENG_intetia_X, ENG_intetia_Y, ENG_intetia_Z);
    matrix33_inverse(&inverse_inertia, inertia_matrix);
    return (vsub( dot_mat33_vectr(inverse_inertia, thrust_matrix) , vcross(dot_mat33_vectr(inverse_inertia, omega), dot_mat33_vectr(inertia_matrix, omega)) ));
}
/* 
        # Position inertial frame [x, y, z]
        pos = state[:3]
        # Velocity inertial frame [x, y, z]
        velocity = state[3:6]
        euler = state[6:9]
        # Angular velocity omega = [p, q, r]
        omega = state[9:12]
*/
void ENG_integrator(integrator_obj_t *out, const Vectr euler, const Vectr omega, const float32_t coll_thrust, const Vectr desired_angular_acc)
{	
    /* # Derivative of euler angles [dphi/dt, dtheta/dt, dpsi/dt]  euler_dot = self._euler_dot */     
    if (out != NULL) 
    {		
      out->moments = ENG_moments(desired_angular_acc, omega);                   /* omega = self.dt_eulerangles_to_angular_velocity(euler_dot, euler) */
      out->thrusts = ENG_motor_thrust(out->moments, coll_thrust);
      out->acc = ENG_acceleration(out->thrusts, euler);                         /* Acceleration in inertial frame */
      out->omega_dot = ENG_angular_acceleration(omega, out->thrusts);
      out->euler_dot = ENG_angular_velocity_to_dt_eulerangles(omega, euler);
    } else { /* for misra */ }
}		
#endif